<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Header Navigation Debug Tool</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .debug-panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .debug-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }
        .debug-info {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            background: #f8f8f8;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            white-space: pre-wrap;
        }
        .test-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .test-button:hover {
            background: #0056b3;
        }
        .status {
            padding: 5px 10px;
            border-radius: 4px;
            margin: 5px 0;
            font-weight: bold;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.warning { background: #fff3cd; color: #856404; }
        .status.error { background: #f8d7da; color: #721c24; }
        iframe {
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="debug-panel">
        <div class="debug-title">ğŸ” Header Navigation Debug Tool</div>
        <p>é€™å€‹å·¥å…·å¯ä»¥å¹«åŠ©åˆ†æ HeaderNavigation_test.vue çµ„ä»¶çš„ä¸‹æ‹‰é¸å–®ä½ç½®å’Œå°é½Šå•é¡Œã€‚</p>
        
        <button class="test-button" onclick="analyzeHeader()">åˆ†æ Header çµæ§‹</button>
        <button class="test-button" onclick="testDropdowns()">æ¸¬è©¦ä¸‹æ‹‰é¸å–®</button>
        <button class="test-button" onclick="testHoverEffects()">æ¸¬è©¦æ‡¸åœæ•ˆæœ</button>
        <button class="test-button" onclick="checkAlignment()">æª¢æŸ¥å°é½Š</button>
        
        <div id="results"></div>
    </div>

    <div class="debug-panel">
        <div class="debug-title">ğŸ“± æ¸¬è©¦é é¢é è¦½</div>
        <iframe src="http://localhost:3000/test-header" id="testFrame"></iframe>
    </div>

    <script>
        function log(message, type = 'info') {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.className = `status ${type}`;
            div.textContent = message;
            results.appendChild(div);
        }

        function logCode(code) {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.className = 'debug-info';
            div.textContent = code;
            results.appendChild(div);
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        async function analyzeHeader() {
            clearResults();
            log('é–‹å§‹åˆ†æ Header çµæ§‹...', 'info');
            
            try {
                const frame = document.getElementById('testFrame');
                const frameDoc = frame.contentDocument || frame.contentWindow.document;
                
                // åˆ†æä¸»è¦å®¹å™¨
                const headerContainer = frameDoc.querySelector('header .max-w-7xl');
                if (headerContainer) {
                    const rect = headerContainer.getBoundingClientRect();
                    log(`âœ… Header å®¹å™¨æ‰¾åˆ°`, 'success');
                    logCode(`Header å®¹å™¨å°ºå¯¸:
å¯¬åº¦: ${rect.width}px
é«˜åº¦: ${rect.height}px
å·¦é‚Šè·: ${rect.left}px
å³é‚Šè·: ${rect.right}px`);
                } else {
                    log('âŒ æ‰¾ä¸åˆ° Header å®¹å™¨', 'error');
                }

                // åˆ†æå°èˆªé …ç›®
                const navItems = frameDoc.querySelectorAll('nav .relative.group');
                log(`âœ… æ‰¾åˆ° ${navItems.length} å€‹å°èˆªé …ç›®`, 'success');
                
                navItems.forEach((item, index) => {
                    const button = item.querySelector('button');
                    const text = button ? button.textContent.trim() : 'æœªçŸ¥';
                    const rect = item.getBoundingClientRect();
                    logCode(`å°èˆªé …ç›® ${index + 1}: "${text}"
ä½ç½®: (${rect.left}, ${rect.top})
å°ºå¯¸: ${rect.width} x ${rect.height}`);
                });

            } catch (error) {
                log(`âŒ åˆ†æå¤±æ•—: ${error.message}`, 'error');
            }
        }

        async function testDropdowns() {
            clearResults();
            log('é–‹å§‹æ¸¬è©¦ä¸‹æ‹‰é¸å–®...', 'info');
            
            try {
                const frame = document.getElementById('testFrame');
                const frameDoc = frame.contentDocument || frame.contentWindow.document;
                
                const navItems = frameDoc.querySelectorAll('nav .relative.group');
                
                for (let i = 0; i < navItems.length; i++) {
                    const navItem = navItems[i];
                    const button = navItem.querySelector('button');
                    const dropdown = navItem.querySelector('.absolute.top-full');
                    const text = button ? button.textContent.trim() : `é …ç›® ${i + 1}`;
                    
                    log(`æ¸¬è©¦ "${text}" ä¸‹æ‹‰é¸å–®...`, 'info');
                    
                    if (dropdown) {
                        // è§¸ç™¼æ‡¸åœ
                        const mouseEnterEvent = new MouseEvent('mouseenter', { bubbles: true });
                        navItem.dispatchEvent(mouseEnterEvent);
                        
                        // ç­‰å¾…å‹•ç•«
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        const isVisible = window.getComputedStyle(dropdown).opacity > 0;
                        const rect = dropdown.getBoundingClientRect();
                        
                        if (isVisible) {
                            log(`âœ… "${text}" ä¸‹æ‹‰é¸å–®å¯è¦‹`, 'success');
                            logCode(`ä¸‹æ‹‰é¸å–®å°ºå¯¸:
å¯¬åº¦: ${rect.width}px
é«˜åº¦: ${rect.height}px
å·¦é‚Šè·: ${rect.left}px
å³é‚Šè·: ${rect.right}px
æ˜¯å¦æº¢å‡ºå³é‚Šç•Œ: ${rect.right > window.innerWidth ? 'æ˜¯' : 'å¦'}`);
                        } else {
                            log(`âŒ "${text}" ä¸‹æ‹‰é¸å–®ä¸å¯è¦‹`, 'error');
                        }
                        
                        // ç§»é™¤æ‡¸åœ
                        const mouseLeaveEvent = new MouseEvent('mouseleave', { bubbles: true });
                        navItem.dispatchEvent(mouseLeaveEvent);
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } else {
                        log(`âŒ "${text}" æ‰¾ä¸åˆ°ä¸‹æ‹‰é¸å–®`, 'error');
                    }
                }
                
            } catch (error) {
                log(`âŒ æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
            }
        }

        async function testHoverEffects() {
            clearResults();
            log('é–‹å§‹æ¸¬è©¦æ‡¸åœæ•ˆæœ...', 'info');
            
            try {
                const frame = document.getElementById('testFrame');
                const frameDoc = frame.contentDocument || frame.contentWindow.document;
                
                // å…ˆè§¸ç™¼ç¬¬ä¸€å€‹ä¸‹æ‹‰é¸å–®
                const firstNav = frameDoc.querySelector('nav .relative.group');
                if (firstNav) {
                    const mouseEnterEvent = new MouseEvent('mouseenter', { bubbles: true });
                    firstNav.dispatchEvent(mouseEnterEvent);
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    const groupItems = frameDoc.querySelectorAll('.group-item');
                    log(`âœ… æ‰¾åˆ° ${groupItems.length} å€‹å¯æ‡¸åœé …ç›®`, 'success');
                    
                    if (groupItems.length > 0) {
                        const firstItem = groupItems[0];
                        const h5 = firstItem.querySelector('h5');
                        
                        if (h5) {
                            const beforeColor = window.getComputedStyle(h5).color;
                            log(`æ‡¸åœå‰é¡è‰²: ${beforeColor}`, 'info');
                            
                            // è§¸ç™¼æ‡¸åœ
                            const hoverEvent = new MouseEvent('mouseenter', { bubbles: true });
                            firstItem.dispatchEvent(hoverEvent);
                            await new Promise(resolve => setTimeout(resolve, 100));
                            
                            const afterColor = window.getComputedStyle(h5).color;
                            log(`æ‡¸åœå¾Œé¡è‰²: ${afterColor}`, 'info');
                            
                            if (beforeColor !== afterColor) {
                                log('âœ… æ‡¸åœæ•ˆæœæ­£å¸¸å·¥ä½œ', 'success');
                            } else {
                                log('âš ï¸ æ‡¸åœæ•ˆæœå¯èƒ½æœªç”Ÿæ•ˆ', 'warning');
                            }
                        }
                    }
                }
                
            } catch (error) {
                log(`âŒ æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
            }
        }

        async function checkAlignment() {
            clearResults();
            log('é–‹å§‹æª¢æŸ¥å°é½Š...', 'info');
            
            try {
                const frame = document.getElementById('testFrame');
                const frameDoc = frame.contentDocument || frame.contentWindow.document;
                
                const headerContainer = frameDoc.querySelector('header .max-w-7xl');
                const navItems = frameDoc.querySelectorAll('nav .relative.group');
                
                if (headerContainer && navItems.length > 0) {
                    const headerRect = headerContainer.getBoundingClientRect();
                    
                    for (let i = 0; i < navItems.length; i++) {
                        const navItem = navItems[i];
                        const button = navItem.querySelector('button');
                        const dropdown = navItem.querySelector('.absolute.top-full');
                        const text = button ? button.textContent.trim() : `é …ç›® ${i + 1}`;
                        
                        // è§¸ç™¼æ‡¸åœé¡¯ç¤ºä¸‹æ‹‰é¸å–®
                        const mouseEnterEvent = new MouseEvent('mouseenter', { bubbles: true });
                        navItem.dispatchEvent(mouseEnterEvent);
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        if (dropdown) {
                            const dropdownRect = dropdown.getBoundingClientRect();
                            
                            // æª¢æŸ¥å°é½Š
                            const leftAlignDiff = Math.abs(dropdownRect.left - headerRect.left);
                            const rightAlignDiff = Math.abs(dropdownRect.right - headerRect.right);
                            const centerAlignDiff = Math.abs((dropdownRect.left + dropdownRect.width/2) - (headerRect.left + headerRect.width/2));
                            
                            log(`"${text}" å°é½Šåˆ†æ:`, 'info');
                            logCode(`Header å®¹å™¨: ${headerRect.left} - ${headerRect.right} (å¯¬åº¦: ${headerRect.width})
ä¸‹æ‹‰é¸å–®: ${dropdownRect.left} - ${dropdownRect.right} (å¯¬åº¦: ${dropdownRect.width})
å·¦å°é½Šå·®ç•°: ${leftAlignDiff.toFixed(2)}px
å³å°é½Šå·®ç•°: ${rightAlignDiff.toFixed(2)}px
ä¸­å¿ƒå°é½Šå·®ç•°: ${centerAlignDiff.toFixed(2)}px`);
                            
                            if (leftAlignDiff < 10 && rightAlignDiff < 10) {
                                log(`âœ… "${text}" å®Œç¾å°é½Š`, 'success');
                            } else if (centerAlignDiff < 20) {
                                log(`âœ… "${text}" ä¸­å¿ƒå°é½Šè‰¯å¥½`, 'success');
                            } else {
                                log(`âš ï¸ "${text}" å°é½Šå¯èƒ½éœ€è¦èª¿æ•´`, 'warning');
                            }
                        }
                        
                        // ç§»é™¤æ‡¸åœ
                        const mouseLeaveEvent = new MouseEvent('mouseleave', { bubbles: true });
                        navItem.dispatchEvent(mouseLeaveEvent);
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                }
                
            } catch (error) {
                log(`âŒ æª¢æŸ¥å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // é é¢è¼‰å…¥å®Œæˆå¾Œè‡ªå‹•åˆ†æ
        window.addEventListener('load', () => {
            setTimeout(() => {
                log('ğŸš€ Debug Tool å·²æº–å‚™å°±ç·’', 'success');
                log('é»æ“Šä¸Šæ–¹æŒ‰éˆ•é–‹å§‹åˆ†æ Header Navigation çµ„ä»¶', 'info');
            }, 1000);
        });
    </script>
</body>
</html>
